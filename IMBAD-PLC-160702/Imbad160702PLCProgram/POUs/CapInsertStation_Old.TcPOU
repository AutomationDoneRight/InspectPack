<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.6">
  <POU Name="CapInsertStation_Old" Id="{ff2a90af-d06a-446f-854b-9b39887586da}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK PUBLIC CapInsertStation_Old
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	xTrigger :BOOL := FALSE; // triggers processing
	State : eCapInsertStaState := eCapInsertStaState.eUnknown;
	NextState : eCapInsertStaState := eCapInsertStaState.eUnknown;
	bFirst : BOOL := TRUE;
	VUT : BYTE; //VehicleID Under Station
	DwellTimer : TON;		
	StateTimer : TON;
	PartPresentTimer : TON;
	CapInstallRetries : BYTE :=0;
	CapPickUpRetries : BYTE := 0;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//////////////////// ESTOP TO STATION DISABLED
// If Cap Station is disabled, then we want to make sure that we have the SMAC homed and not in the way of barrels
// we also want to check if the pallet hold downs and center pins are in the correct position
// if all above conditions are true, then we want to wait in a station disabled ready state
////////////////// STATION DISABLED - STATION ENABLED
// We have to go pick up a cap and not bring the station in ready condition until cap
// is picked up
/////////////////////// STATION ENABLED - STATION DISABLED
// We have to let go of the vacuum in the tool, and set Next State to Station Disabled Ready
//////////////////////// ESTOP- STATION ENABLED
//// Follow all the logic to get the station ready

IF (GVL_IO.MachineEStopped) THEN 
	State := eCapInsertStaState.eUnknown;
	NextState := eCapInsertStaState.eUnknown;
	Status.CapStatusMsg:= 'CapSta Unknown State, Check AIR, E-STOP and Hit Start';
END_IF

CASE State OF

eCapInsertStaState.eUnknown:
	   IF (GVL_IO.MC_XStartPB AND GVL_IO.MC_XAirPressureOK AND GVL_IO.MC_NotEStopped) THEN // wait for start button when powered up or PLC program restarted
			NextState := eCapInsertStaState.eSMACMtrSendHome;	   
	   END_IF
	GVL_IO.CP_YEscapeWallCylinderExtend:= FALSE;
	GVL_IO.CP_YEscapeWallCylinderRetract := TRUE;
	GVL_IO.CP_YToolVacuumON := FALSE;
	GVL_IO.CP_YToolVacuumOFF := FALSE;	
	GVL_IO.CP_YEscapementToBowl:= FALSE; /// now we have a center OFF valve, turning both valves off will result in air getting dumped	
	GVL_IO.CP_YEscapementToPick:= FALSE;
	StateTimer(IN:=TRUE, PT:= T#9.5S); // give a message out every 10 seconds
	IF (StateTimer.Q) THEN
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_Unknown, SourceID:= Logging.SrcCapPOU);
		StateTimer(IN:=FALSE);
	END_IF
	
	//Status.StationInfoString[MM_CONST.CAP_STA_HMI_STATE] := '';
	//Status.StationStatusString[MM_CONST.CAP_STA_HMI_STATE] := '';

eCapInsertStaState.eSMACMtrSendHome:
	GVL_IO.CP_YSMAC0 := FALSE;
	GVL_IO.CP_YSMAC1 := TRUE;
	GVL_IO.CP_YSMAC2 := TRUE;
	GVL_IO.CP_YSMAC3 := FALSE;
	DwellTimer(IN:=TRUE, PT:= T#100MS);	
	IF (DwellTimer.Q) THEN
		GVL_IO.CP_YSMAC3 := TRUE; // rising edge to trigger the selected SMAC routine every 5 seconds
		DwellTimer(IN:=FALSE);
		NextState := eCapInsertStaState.eSMACMtrCheckHomed;
	END_IF

eCapInsertStaState.eSMACMtrCheckHomed:
	DwellTimer (IN:= TRUE, PT:= T#250MS);
	IF (DwellTimer.Q) THEN
		 IF (GVL_IO.CP_XSmac2) THEN
		NextState := eCapInsertStaState.eInit;
		GVL_IO.CP_YSMAC3 := FALSE;
		DwellTimer(IN:=FALSE);
		END_IF		
	END_IF
    
	StateTimer(IN:=TRUE, PT:= T#10S); // give a message out every 10 seconds
	IF (StateTimer.Q) THEN
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_MtrCheckHome, SourceID:= Logging.SrcCapPOU);
		StateTimer(IN:=FALSE);		
		NextState:= eCapInsertStaState.eUnknown; // Operator check what the problem is and then hit the start button again
		GVL_IO.CP_YSMAC3 := FALSE;
		Status.CapStatusMsg:= 'Could not home SMAC, check if SMAC is ON !!';
	END_IF

eCapInsertStaState.eInit:
         GVL_IO.CP_YEscapeWallCylinderExtend:= FALSE;
		 GVL_IO.CP_YEscapeWallCylinderRetract := TRUE; /// we want to check if there is a cap present in the escapement, so need to extend the wall.
		 GVL_IO.CP_YPalletHoldDownExtend := FALSE;
		 GVL_IO.CP_YPalletHoldDownRetract := TRUE;
		 GVL_IO.CP_YBarellCenterPinExtend := FALSE;
		 GVL_IO.CP_YBarellCenterPinRetract := TRUE;
		 GVL_IO.CP_YToolVacuumOFF:= FALSE;
		 GVL_IO.CP_YToolVacuumON:= TRUE; // don't know if vacuum needs to be on, but doesn't hurt to keep it on for 1.5 seconds
		 GVL_IO.CP_YEscapementToBowl := FALSE; // do not move the escapement cyclinder anywhere 
		 GVL_IO.CP_YEscapementToPick := FALSE; // do not move escapement until we read the state of the part presence sensors in tool and escapement
         DwellTimer(IN:= TRUE, PT:= T#1.5S);
		 IF (DwellTimer.Q) THEN
			 DwellTimer(IN:=FALSE);
			 NextState:= eCapInsertStaState.eHoming; 
		 END_IF
			
eCapInsertStaState.eHoming:	
	IF (GVL_IO.CP_XPalletHoldDownHome AND NOT GVL_IO.CP_XPalletHoldDownExtended 
           AND GVL_IO.CP_XSmac2 (*AND GVL_IO.CP_XBarellCenterPinRetracted AND NOT GVL_IO.CP_XBarellCenterPinExtended*) ) THEN  
		   NextState := eCapInsertStaState.eDetermineEscapementPos;	
           IF (NOT LotsData.Lot.CapInsertEnabled) THEN
				NextState :=  eCapInsertStaState.eDisabledReady;
           END_IF 	   
		   DwellTimer(IN:=FALSE);
	END_IF
	StateTimer(IN:=TRUE, PT:= T#10S); // give a message out every 10 seconds
	IF (StateTimer.Q) THEN
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_AllCheckHome, SourceID:= Logging.SrcCapPOU);
		StateTimer(IN:=FALSE);		
		NextState:= eCapInsertStaState.eUnknown; // Operator check what the problem is and then hit the start button again
		Status.CapStatusMsg:= 'Pallet Hold Down NOT HOME check Cylinders!!';
	END_IF

eCapInsertStaState.eDisabledReady:
	GVL_IO.CP_YToolVacuumOFF:= TRUE;
	GVL_IO.CP_YToolVacuumON:= FALSE;
	IF (LotsData.Lot.CapInsertEnabled) THEN 
		NextState := eCapInsertStaState.eUnknown; // force the operator to hit the start button if station is enabled.
	END_IF
	IF (xTrigger) THEN // vehicles that have been previously commanded to come here before station was disabled 
		NextState := eCapInsertStaState.eDepart;
	END_IF
	Status.CapStatusMsg:= 'Cap Station Disabled, but clear for pallets to move!!';

eCapInsertStaState.eDetermineEscapementPos:

	// First check where the escapement cylinder is located. 
            // If escapement cylinder is at bowl, and if the part present in tool sensor is ON, then we have a part in the tool. We can declare that cap is picked up. 
            // If escapement cyclinder is at bowl, and if the part present in tool sensor is OFF, then we have to wait for a part to be present in the escapement from the bowl feeder
            // If escapment cylinder is at pick location, and there is a part in the tool sensor as well as the part in the escapement, then we part underneath that needs to be picked up by SMAC
			// If escapment cyclinder is at pick location, and there is a part in the tool sensor and no part in the escapement, then we can declare that the cap is picked up.
            // If the escapement is at the pick location, and there is a no part in the tool sensor and no part in the escapement, send the escapement cylinder to the bowl 
            // If the escapement position is undetermined, then if there is no part in the tool and no part in the escapement, send escapement back to bowl
            // If the escapement position is undetermined and if there is a part in the tool and not one in the escapement, then declare that cap is picked up
            // If the escapement position is undetermined and if there is no part in the tool and part is present in escapement, move the part to be picked up
            // If the escapement position is undetermined and if there is a part in the tool and a part in the escapement, then call the operator !!!  
            
			IF (GVL_IO.CP_XEscapementAtBowl AND NOT GVL_IO.CP_XEscapementAtPickUp) THEN // escapement at the bowl
				IF (GVL_IO.CP_XVacuumCapPicked) THEN // we have a part in the tool..
					NextState := eCapInsertStaState.eSendEscapementToBowlNext; // this will pressurize the valves and then wait for vehicle trigger
				ELSE // we have to fetch a part from the bowl location
					NextState:= eCapInsertStaState.eSendEscapementToBowl;
                END_IF
			ELSIF (NOT GVL_IO.CP_XEscapementAtBowl AND GVL_IO.CP_XEscapementAtPickUp) THEN // at the pick location 
				IF (GVL_IO.CP_XVacuumCapPicked AND GVL_IO.CP_XCapPresentEscapment) THEN //we have to pick up this part with the SMAC
					NextState := eCapInsertStaState.eSendEscapementToPick;
				ELSIF(GVL_IO.CP_XVacuumCapPicked AND NOT GVL_IO.CP_XCapPresentEscapment) THEN
				     NextState := eCapInsertStaState.eSendEscapementToBowlNext; // this will pressurize the valves and then wait for vehicle trigger
				ELSIF (NOT GVL_IO.CP_XVacuumCapPicked AND NOT GVL_IO.CP_XCapPresentEscapment) THEN
					NextState:= eCapInsertStaState.eSendEscapementToBowl;
				ELSE
                    NextState := eCapInsertStaState.eUnknown; //send message to HMI over here .. something is wrong with the sensor 
					Status.CapStatusMsg:= 'Check sensor for Cap detection!!';
				END_IF
            ELSE // undetermined location  
				IF (NOT GVL_IO.CP_XVacuumCapPicked AND NOT 	GVL_IO.CP_XCapPresentEscapment) THEN
					NextState:= eCapInsertStaState.eSendEscapementToBowl;
				ELSIF(GVL_IO.CP_XVacuumCapPicked AND NOT GVL_IO.CP_XCapPresentEscapment) THEN
                    NextState := eCapInsertStaState.eSendEscapementToBowlNext; // this will pressurize the valves and then wait for vehicle trigger
				ELSIF(NOT GVL_IO.CP_XVacuumCapPicked AND GVL_IO.CP_XCapPresentEscapment) THEN
 	                NextState := eCapInsertStaState.eSendEscapementToPick;
                ELSIF ( GVL_IO.CP_XVacuumCapPicked AND GVL_IO.CP_XCapPresentEscapment) THEN
                    NextState := eCapInsertStaState.eUnknown; //send message to HMI over here 	
                    Status.CapStatusMsg:= 'Clear CAPS from the Escapement!!';			
                END_IF
			END_IF
	
eCapInsertStaState.eReady: // we need to bypass this state because we added the complex determination of next state from above
	IF (NOT GVL_IO.CP_XPalletHoldDownHome OR GVL_IO.CP_XPalletHoldDownExtended) THEN
		   NextState := eCapInsertStaState.eInit;		   
	  END_IF
	  GVL_IO.CP_YToolVacuumOFF:= FALSE;
	  GVL_IO.CP_YToolVacuumON:= TRUE;
	  DwellTimer(IN:= TRUE, PT:= T#250MS);
	  IF (DwellTimer.Q) THEN
		  DwellTimer(IN:=FALSE);
		  IF (GVL_IO.CP_XVacuumCapPicked) THEN //Cap Already Present 
		  	 NextState := eCapInsertStaState.eWaitForVehicleTrigger;
	      ELSE
			  NextState := eCapInsertStaState.eSendEscapementToBowl;               
			 GVL_IO.CP_YToolVacuumOFF:= TRUE;
		     GVL_IO.CP_YToolVacuumON:= FALSE;
	  	  END_IF	  
	  END_IF
	  

eCapInsertStaState.eSendEscapementToBowl:
	GVL_IO.CP_YToolVacuumOFF:= TRUE;
	  GVL_IO.CP_YToolVacuumON:= FALSE;
    GVL_IO.CP_YEscapementToBowl := TRUE;
	GVL_IO.CP_YEscapementToPick := FALSE;
	IF (GVL_IO.CP_XEscapementAtBowl AND NOT GVL_IO.CP_XEscapementAtPickUp) THEN
    	NextState:= eCapInsertStaState.eEscapementAtBowl; 	
	END_IF	
	StateTimer(IN:=TRUE, PT:= T#5S);
	IF (StateTimer.Q) THEN
		NextState:= eCapInsertStaState.eUnknown;
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_CheckEscapeCylinders, SourceID:= Logging.SrcCapPOU);
		StateTimer(IN:=FALSE);
		Status.CapStatusMsg:= 'Escapement Did Not reach Bowl, Clear Caps!!';
	END_IF

eCapInsertStaState.eEscapementAtBowl:
  IF (GVL_IO.CP_XCapPresentEscapment) THEN
		PartPresentTimer(IN:= TRUE, PT:= T#100MS); // wait for part to be fully pushed against the back wall
		IF (PartPresentTimer.Q) THEN
			PartPresentTimer(IN:=FALSE);
			NextState := eCapInsertStaState.eSendEscapementToPick;
		END_IF
	ELSE
		PartPresentTimer(IN:=FALSE); //Reset the part present timer here
	END_IF 	

	StateTimer(IN:=TRUE, PT:= T#10S); // give a message out every 10 seconds, hang out here indefinitely to wait for Parts to be present from Bowl feeder. We might want to signal something in the light tower
	IF (StateTimer.Q) THEN
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_WaitCap, SourceID:= Logging.SrcCapPOU);
		StateTimer(IN:=FALSE);
		Status.CapStatusMsg:= 'No CAP from BOWL. Is Bowl ON?!!';
		NextState := eCapInsertStaState.eUnknown;
	END_IF    
	
	
eCapInsertStaState.eSendEscapementToPick:
   	GVL_IO.CP_YToolVacuumOFF:= TRUE;
    GVL_IO.CP_YToolVacuumON:= FALSE; 
   GVL_IO.CP_YEscapementToBowl := FALSE;
	GVL_IO.CP_YEscapementToPick := TRUE;	
	IF (NOT GVL_IO.CP_XEscapementAtBowl AND GVL_IO.CP_XEscapementAtPickUp) THEN
    		NextState := eCapInsertStaState.eEscapementAtPick;
	END_IF
	
	DwellTimer(IN:=TRUE, PT:= T#5S);
	IF (DwellTimer.Q) THEN
		NextState:= eCapInsertStaState.eInit;
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_CheckEscapeCylinders, SourceID:= Logging.SrcCapPOU);
		DwellTimer(IN:=FALSE);
		Status.CapStatusMsg:= 'Escapement NOT at Pick- CHECK JAMS, Clear and Hit Start!!';
		NextState := eCapInsertStaState.eUnknown;
	END_IF

eCapInsertStaState.eEscapementAtPick:    
	DwellTimer(IN:=TRUE, PT:= T#100MS);
	IF (DwellTimer.Q) THEN
	 NextState := eCapInsertStaState.eExtendWallCylinder;	
	 DwellTimer(IN:=FALSE);
	END_IF
     

eCapInsertStaState.eExtendWallCylinder:
    GVL_IO.CP_YEscapeWallCylinderExtend := TRUE;
	GVL_IO.CP_YEscapeWallCylinderRetract := FALSE;
	DwellTimer(IN:=TRUE, PT:= T#250MS);
	IF (DwellTimer.Q) THEN
		NextState := eCapInsertStaState.eRequestSMACCapPick;	 	
		DwellTimer(IN:=FALSE);
	END_IF	

eCapInsertStaState.eRequestSMACCapPick:
    GVL_IO.CP_YSMAC0 := FALSE;
	GVL_IO.CP_YSMAC1 := TRUE;
	GVL_IO.CP_YSMAC2 := FALSE;
	GVL_IO.CP_YSMAC3 := FALSE;
	DwellTimer(IN:=TRUE, PT:= T#50MS);	
	IF (DwellTimer.Q) THEN
		GVL_IO.CP_YSMAC3 := TRUE; // rising edge to trigger the selected SMAC routine every 5 seconds
		DwellTimer(IN:=FALSE);
		CapPickUpRetries := CapPickUpRetries + 1;
		NextState := eCapInsertStaState.eWaitForCapPickDone;
		StateTimer(IN:=FALSE);
	END_IF
	
eCapInsertStaState.eWaitForCapPickDone:
	DwellTimer(IN:=TRUE, PT:= T#150MS);
	IF (DwellTimer.Q) THEN
		IF (GVL_IO.CP_XSmac2 AND NOT GVL_IO.CP_XSmac1 AND GVL_IO.CP_XSmac0 ) THEN
			NextState := eCapInsertStaState.eTurnVacuumON;
			GVL_IO.CP_YSMAC3 := FALSE;
			DwellTimer(IN:=FALSE);
			CapPickUpRetries := 0;
		END_IF	
	END_IF   
	StateTimer(IN:=TRUE, PT:= T#4.5S); // SMAC timeouts in 5 seconds.
	IF (StateTimer.Q) THEN
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_MtrWaitCapPickCmpl, SourceID:= Logging.SrcCapPOU);
		StateTimer(IN:=FALSE);
		GVL_IO.CP_YSMAC3 := FALSE;		
		IF (CapPickupRetries < CONFIG.CAP_PICKUP_RETRIES ) THEN
			//NextState:=  eCapInsertStaState.eWallCylinderBackAndForth; // Operator check what the problem is and then hit the start button again; 
			  NextState := eCapInsertStaState.eRequestSMACCapPick; //Bonnie doesn't want the cyclinder wall to retract
              DwellTimer(IN:=FALSE);
 		ELSE
	    	NextState:= eCapInsertStaState.eUnknown ; // Operator check what the problem is and then hit the start button again;
			CapPickUpRetries := 0;
			Status.CapStatusMsg:= 'SMAC could not pick up CAP. Check CAP, then HIT START!!';
			NextState := eCapInsertStaState.eUnknown;
		END_IF		
	END_IF
	
eCapInsertStaState.eWallCylinderBackAndForth:
    GVL_IO.CP_YEscapeWallCylinderExtend := FALSE;
	GVL_IO.CP_YEscapeWallCylinderRetract := TRUE;
	DwellTimer(IN:=TRUE, PT:= T#250MS);
	IF (DwellTimer.Q) THEN		
		GVL_IO.CP_YEscapeWallCylinderExtend := TRUE;
		GVL_IO.CP_YEscapeWallCylinderRetract := FALSE;
		StateTimer(IN:= TRUE, PT := T#250MS);
		IF (StateTimer.Q) THEN        	
			NextState:= eCapInsertStaState.eRequestSMACCapPick;
			StateTimer(IN:=FALSE);
			DwellTimer(IN:=FALSE);
		END_IF
	END_IF
	
	
eCapInsertStaState.eTurnVacuumON:
	GVL_IO.CP_YToolVacuumON := TRUE;
	GVL_IO.CP_YToolVacuumOFF := FALSE;
	IF (GVL_IO.CP_XVacuumCapPicked) THEN
		NextState := eCapInsertStaState.eRetractWallCylinder; 
	END_IF
	DwellTimer(IN:=TRUE, PT:= T#150MS);
	IF (DwellTimer.Q) THEN
		//IF (GVL_IO.CP_XVacuumCapPicked) THEN
			NextState := eCapInsertStaState.eRetractWallCylinder; // do it anyways, because we aren't sure if the sensor is stable
			DwellTimer(IN:=FALSE);
	//	END_IF	
	END_IF   
	
eCapInsertStaState.eRetractWallCylinder:
	GVL_IO.CP_YEscapeWallCylinderExtend := FALSE;
	GVL_IO.CP_YEscapeWallCylinderRetract := TRUE;
	DwellTimer(IN:=TRUE, PT:= T#100MS);
	IF (DwellTimer.Q) THEN
		NextState := eCapInsertStaState.eRequestSMACHomeAfterPick;
		DwellTimer(IN:=FALSE); 	
	END_IF    
	

eCapInsertStaState.eRequestSMACHomeAfterPick:
    GVL_IO.CP_YSMAC0 := FALSE;
	GVL_IO.CP_YSMAC1 := FALSE;
	GVL_IO.CP_YSMAC2 := FALSE;
	GVL_IO.CP_YSMAC3 := FALSE;
	DwellTimer(IN:=TRUE, PT:= T#50MS);	
	IF (DwellTimer.Q) THEN
		GVL_IO.CP_YSMAC3 := TRUE; // rising edge to trigger the selected SMAC routine every 5 seconds
		DwellTimer(IN:=FALSE);
		NextState := eCapInsertStaState.eWaitForSMACHomeAfterPick;  	
	END_IF  

eCapInsertStaState.eWaitForSMACHomeAfterPick:	
	DwellTimer(IN:=TRUE, PT:= T#100MS);
	IF (DwellTimer.Q) THEN
		IF (GVL_IO.CP_XSmac2 AND GVL_IO.CP_XSmac1 AND GVL_IO.CP_XSmac0 ) THEN
			NextState := eCapInsertStaState.eSendEscapementToBowlNext;
			GVL_IO.CP_YSMAC3 := FALSE;
			DwellTimer(IN:=FALSE);
		END_IF	
	END_IF   
	StateTimer(IN:=TRUE, PT:= T#10S); // give a message out every 10 seconds
	IF (StateTimer.Q) THEN
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_MtrWaitReturnHomeCmpl, SourceID:= Logging.SrcCapPOU);
		StateTimer(IN:=FALSE);		
		NextState:= eCapInsertStaState.eUnknown; // Operator check what the problem is and then hit the start button again
		Status.CapStatusMsg:= 'SMAC Did not Home after PICK-- Check JAMS or is SMAC ON?!!';		
	END_IF
	

eCapInsertStaState.eSendEscapementToBowlNext:

	GVL_IO.CP_YEscapementToBowl := TRUE;
	GVL_IO.CP_YEscapementToPick := FALSE;
	IF (GVL_IO.CP_XEscapementAtBowl AND NOT GVL_IO.CP_XEscapementAtPickUp) THEN
    	NextState:= eCapInsertStaState.eEscapementAtBowlNext; 	
	END_IF
	
	StateTimer(IN:=TRUE, PT:= T#5S);
	IF (StateTimer.Q) THEN
		NextState:= eCapInsertStaState.eInit;
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_CheckEscapeCylinders, SourceID:= Logging.SrcCapPOU);
		StateTimer(IN:=FALSE);
		NextState:= eCapInsertStaState.eUnknown; // Operator check what the problem is and then hit the start button again
		Status.CapStatusMsg:= 'Escapement Did Not Get to Bowl Next.. Clear JAM and Hit START';
	END_IF

eCapInsertStaState.eEscapementatBowlNext:
   NextState := eCapInsertStaState.eWaitForVehicleTrigger;
	
eCapInsertStaState.eWaitForVehicleTrigger:
  
	IF (xTrigger) THEN //XTrigger is signaled when part arrives under the station
		
        NextState := eCapInsertStaState.ePalletHoldDownGoingDown;	
	    PartsData.Status[VUT].OverallStatus := ePartStatus.eReject; 		
		
		DwellTimer(IN:=FALSE);
	END_IF
	
	StateTimer(IN:=TRUE, PT:= T#10S); // give a message out every 10 seconds, hang out here indefinitely to wait for Parts to be present from Bowl feeder. We might want to signal something in the light tower
	IF (StateTimer.Q) THEN
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_WaitVehicle, SourceID:= Logging.SrcCapPOU);
		StateTimer(IN:=FALSE);
		Status.CapStatusMsg:= 'Waiting for CAP Part';
	END_IF


eCapInsertStaState.ePalletHoldDownGoingDown:
	GVL_IO.CP_YPalletHoldDownExtend := TRUE;
	GVL_IO.CP_YPalletHoldDownRetract := FALSE;
	IF (NOT GVL_IO.CP_XPalletHoldDownHome AND GVL_IO.CP_XPalletHoldDownExtended) THEN
		   NextState := eCapInsertStaState.ePalletHoldDownExtended;		   
	   END_IF
	
   DwellTimer(IN:=TRUE, PT:= T#1S); // give a message out every 10 seconds
	IF (DwellTimer.Q) THEN
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_CheckCylinders, SourceID:= Logging.SrcCapPOU);
		DwellTimer(IN:=FALSE);	
	END_IF
	StateTimer(IN:=TRUE, PT:= T#10S);  // if it is more than 10 seconds then we send the station into an unknown state and wait for operator to fix and hit start button again
	IF (StateTimer.Q) THEN
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_CheckCylinders, SourceID:= Logging.SrcCapPOU);
		StateTimer(IN:=FALSE);
		//NextState := eCapInsertStaState.ePalletHoldDownGoingUp; //move the vehicle out.. we need to notify the operator some kind of alarm here 
		NextState:= eCapInsertStaState.eUnknown; // Operator check what the problem is and then hit the start button again
		Status.CapStatusMsg:= 'Pallet Hold Down Not DOWN..check cyclinder/sensor then HIT START';
	END_IF  
   

eCapInsertStaState.ePalletHoldDownExtended:
   // NextState := eCapInsertStaState.eSendBarellCenterPinExtendRaise;
    NextState := eCapInsertStaState.eRequestSMACCapInstall;    // Skip the BarrelCenterPinExtend.
	CapInstallRetries := 0;

eCapInsertStaState.eSendBarellCenterPinExtendRaise:
	GVL_IO.CP_YBarellCenterPinExtend := TRUE;
	GVL_IO.CP_YBarellCenterPinRetract := FALSE;
	DwellTimer(IN:=FALSE);
	NextState := eCapInsertStaState.eCheckBarellCenterPinExtendedRaised;
	
	
eCapInsertStaState.eCheckBarellCenterPinExtendedRaised: // Note that these sensors are removed from the machine
    IF (NOT GVL_IO.CP_XBarellCenterPinRetracted AND GVL_IO.CP_XBarellCenterPinExtended) THEN
		DwellTimer(IN:= TRUE, PT := T#50MS);
		IF (DwellTimer.Q) THEN
			NextState := eCapInsertStaState.eRequestSMACCapInstall;
			DwellTimer(IN:=FALSE);			
		END_IF
	END_IF
	
	StateTimer(IN:=TRUE, PT:= T#10S);  // if it is more than 10 seconds then we send the station into an unknown state and wait for operator to fix and hit start button again
	IF (StateTimer.Q) THEN
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_CheckCylinders, SourceID:= Logging.SrcCapPOU);
		StateTimer(IN:=FALSE);
		NextState := eCapInsertStaState.ePalletHoldDownGoingUp; //move the vehicle out.. we need to notify the operator some kind of alarm here 
	END_IF  
	

eCapInsertStaState.eRequestSMACCapInstall:
    IF (LotsData.Lot.BarrelSize = eBarrelType.Size30cc) THEN
		GVL_IO.CP_YSMAC0 := TRUE; // shorter barrel
    ELSE
        GVL_IO.CP_YSMAC0 := FALSE; // longer barrel
	END_IF

	GVL_IO.CP_YSMAC1 := FALSE;
	GVL_IO.CP_YSMAC2 := TRUE;
	GVL_IO.CP_YSMAC3 := FALSE;
	DwellTimer(IN:=TRUE, PT:= T#50MS);	
	IF (DwellTimer.Q) THEN
		GVL_IO.CP_YSMAC3 := TRUE; // rising edge to trigger the selected SMAC routine every 5 seconds
		DwellTimer(IN:=FALSE);
		CapInstallRetries := CapInstallRetries +1;
		NextState := eCapInsertStaState.eWaitForSMACCapInstall;		
	END_IF

eCapInsertStaState.eWaitForSMACCapInstall:
	DwellTimer(IN:=TRUE, PT:= T#150MS);
	IF (DwellTimer.Q) THEN
		IF (GVL_IO.CP_XSmac2 AND GVL_IO.CP_XSmac1 AND NOT GVL_IO.CP_XSmac0 ) THEN
			UpdatePartData();
            NextState := eCapInsertStaState.eRequestSMACHome;
			GVL_IO.CP_YToolVacuumON := FALSE;
			GVL_IO.CP_YToolVacuumOFF := TRUE;
			GVL_IO.CP_YSMAC3 := FALSE;
			DwellTimer(IN:=FALSE);
		END_IF	
	END_IF   
	StateTimer(IN:=TRUE, PT:= T#7S); // give a message out every 10 seconds
	IF (StateTimer.Q) THEN
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_MtrWaitCapInsertCmpl, SourceID:= Logging.SrcCapPOU);
		StateTimer(IN:=FALSE);		
		GVL_IO.CP_YSMAC3 := FALSE;
		IF (CapInstallRetries < CONFIG.CAP_INSTALL_RETRIES) THEN
			NextState := eCapInsertStaState.eRequestSMACCapInstall;
		ELSE
			NextState := eCapInsertStaState.eRequestSMACHome;	 // keep Vacuum ON, we are going to reuse this cap on next part
            CapInstallRetries := 0;	
			//NextState:= eCapInsertStaState.eUnknown; // Operator check what the problem is and then hit the start button again
			 Status.CapStatusMsg:= 'SMAC Cap Install Timed OUT.. ';
		END_IF		
	END_IF

eCapInsertStaState.eRequestSMACHome:
    GVL_IO.CP_YSMAC0 := FALSE;
	GVL_IO.CP_YSMAC1 := FALSE;
	GVL_IO.CP_YSMAC2 := FALSE;
	GVL_IO.CP_YSMAC3 := FALSE;
	DwellTimer(IN:=TRUE, PT:= T#50MS);	
	IF (DwellTimer.Q) THEN
		GVL_IO.CP_YSMAC3 := TRUE; // rising edge to trigger the selected SMAC routine every 5 seconds
		DwellTimer(IN:=FALSE);
		NextState := eCapInsertStaState.eWaitForSMACHome;  	
	END_IF  

eCapInsertStaState.eWaitForSMACHome:	
	DwellTimer(IN:=TRUE, PT:= T#100MS);
	IF (DwellTimer.Q) THEN
		IF (GVL_IO.CP_XSmac2 AND GVL_IO.CP_XSmac1 AND GVL_IO.CP_XSmac0 ) THEN
			NextState := eCapInsertStaState.ePalletHoldDownGoingUp;
			GVL_IO.CP_YSMAC3 := FALSE;
			DwellTimer(IN:=FALSE);
		END_IF	
	END_IF   
	StateTimer(IN:=TRUE, PT:= T#15S); // give a message out every 10 seconds
	IF (StateTimer.Q) THEN
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_MtrWaitReturnHomeCmpl, SourceID:= Logging.SrcCapPOU);
		StateTimer(IN:=FALSE);		
		GVL_IO.CP_YSMAC3 := FALSE;
		//NextState:= eCapInsertStaState.ePalletHoldDownGoingUp; //Unknown; // Operator check what the problem is and then hit the start button again
		NextState:= eCapInsertStaState.eUnknown; // Operator check what the problem is and then hit the start button again
		Status.CapStatusMsg:= 'SMAC Could Not GO Home After CAP install.check for JAMS. Hit Start ';
	END_IF


eCapInsertStaState.ePalletHoldDownGoingUp:
   GVL_IO.CP_YPalletHoldDownExtend := FALSE;
   GVL_IO.CP_YPalletHoldDownRetract := TRUE;
   GVL_IO.CP_YBarellCenterPinExtend := FALSE;
   GVL_IO.CP_YBarellCenterPinRetract := TRUE;
   
   IF (GVL_IO.CP_XPalletHoldDownHome AND NOT GVL_IO.CP_XPalletHoldDownExtended (*AND  
       GVL_IO.CP_XBarellCenterPinRetracted AND NOT GVL_IO.CP_XBarellCenterPinExtended*)) THEN
	   NextState := eCapInsertStaState.ePalletHoldDownUp;
   END_IF
   
    DwellTimer(IN:=TRUE, PT:= T#1S); // give a message out every 10 seconds
	IF (DwellTimer.Q) THEN
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_CheckCylinders, SourceID:= Logging.SrcCapPOU);
		DwellTimer(IN:=FALSE);	
	END_IF
	StateTimer(IN:=TRUE, PT:= T#10S);  // if it is more than 10 seconds then we send the station into an unknown state and wait for operator to fix and hit start button again
	IF (StateTimer.Q) THEN
		Logging.fbEventMsg.SendEventMsg(MsgClass := TCEVENTCLASS_STATEINFO, EventID:= Logging.ID_CP_CheckCylinders, SourceID:= Logging.SrcCapPOU);
		StateTimer(IN:=FALSE);
		//NextState := eCapInsertStaState.eInit; //move the vehicle out.. we need to notify the operator some kind of alarm here 
		NextState:= eCapInsertStaState.eUnknown; // Operator check what the problem is and then hit the start button again
		Status.CapStatusMsg:= 'Pallet Hold Down Not Retracted. Check Cylinders then Press Start ';
	END_IF  

eCapInsertStaState.ePalletHoldDownUp:
   NextState := eCapInsertStaState.eDepart;

eCapInsertStaState.eDepart:
	Stations.fbRoutePlanner.M_NotifyVehStaCmpl(StationIndex:= MM_CONST.CAP_STA, VehicleID := VUT);
	xTrigger := FALSE; // Now that we have sent a vehicle out, we should not work on it anymore 
    IF (Stations.fbCycleControl.StopRequested) THEN		
		NextState := eCapInsertStaState.eStopActive;
	ELSE
		NextState := eCapInsertStaState.eHoming;
	END_IF

eCapInsertStaState.eStopActive:
IF (NOT Stations.fbCycleControl.StopRequested) THEN		
		NextState := eCapInsertStaState.eHoming;
END_IF	
    Status.CapStatusMsg:= 'Cap Stop Active, Press Start to Run';
	
eCapInsertStaState.eError:
END_CASE

IF (State <> NextState) THEN
	bFirst := TRUE;
	StateTimer(IN:=FALSE);
ELSE
	bFirst := FALSE;
END_IF

State := NextState;
AssignStationStatusForHMI();
]]></ST>
    </Implementation>
    <Method Name="AssignStationStatusForHMI" Id="{50e26fa9-ca18-44f2-8285-906a1d0ac974}">
      <Declaration><![CDATA[METHOD PUBLIC AssignStationStatusForHMI : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Status.StationsState[MM_CONST.CAP_STA_HMI_STATE] := State;
IF (NOT LotsData.Lot.CapInsertEnabled) THEN
	Status.StationStauts[MM_CONST.CAP_STA_HMI_STATE] := OverallStationStatus.eDisabled;
ELSE	
	CASE State OF
	eCapInsertStaState.eUnknown,eCapInsertStaState.eError: 
		Status.StationStauts[MM_CONST.CAP_STA_HMI_STATE] := OverallStationStatus.eError;
		
	eCapInsertStaState.eSMACMtrSendHome,eCapInsertStaState.eSMACMtrCheckHomed,eCapInsertStaState.eInit,eCapInsertStaState.eHoming,eCapInsertStaState.eReady,
	eCapInsertStaState.eSendEscapementToBowl,eCapInsertStaState.eSendEscapementToPick,eCapInsertStaState.eEscapementAtPick,
	eCapInsertStaState.eExtendWallCylinder, eCapInsertStaState.eRequestSMACCapPick,eCapInsertStaState.eWaitForCapPickDone,eCapInsertStaState.eWallCylinderBackAndForth,
	eCapInsertStaState.eTurnVacuumON,eCapInsertStaState.eRetractWallCylinder,eCapInsertStaState.eRequestSMACHomeAfterPick,eCapInsertStaState.eWaitForSMACHomeAfterPick,
	eCapInsertStaState.eSendEscapementToBowlNext,eCapInsertStaState.eEscapementatBowlNext:
	    Status.StationStauts[MM_CONST.CAP_STA_HMI_STATE] := OverallStationStatus.eHoming;
	
    eCapInsertStaState.eEscapementAtBowl:
	    Status.StationStauts[MM_CONST.CAP_STA_HMI_STATE] := OverallStationStatus.eWarning;
    
   eCapInsertStaState.eWaitForVehicleTrigger:
	    Status.StationStauts[MM_CONST.CAP_STA_HMI_STATE] := OverallStationStatus.eWaitingForParts;
	
    eCapInsertStaState.ePalletHoldDownGoingDown,eCapInsertStaState.ePalletHoldDownExtended,eCapInsertStaState.eSendBarellCenterPinExtendRaise,eCapInsertStaState.eCheckBarellCenterPinExtendedRaised,
	eCapInsertStaState.eRequestSMACCapInstall,eCapInsertStaState.eWaitForSMACCapInstall,eCapInsertStaState.eRequestSMACHome,eCapInsertStaState.eWaitForSMACHome,eCapInsertStaState.ePalletHoldDownGoingUp,
	eCapInsertStaState.ePalletHoldDownUp: 
	    Status.StationStauts[MM_CONST.CAP_STA_HMI_STATE] := OverallStationStatus.eRunning;
    
    eCapInsertStaState.eStopActive:
        Status.StationStauts[MM_CONST.CAP_STA_HMI_STATE] := OverallStationStatus.eCycleStop;	
   
    ELSE ;	
	END_CASE
END_IF
 ]]></ST>
      </Implementation>
    </Method>
    <Method Name="ClearVehicleTrigger" Id="{987f4fd6-e298-4681-98ac-c3ac2849393a}">
      <Declaration><![CDATA[METHOD PUBLIC ClearVehicleTrigger : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[xTrigger := FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="IsFaulted" Id="{9a16851e-4ff2-4b07-921b-e8667bc68fe6}">
      <Declaration><![CDATA[METHOD PUBLIC IsFaulted : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (LotsData.Lot.CapInsertEnabled) THEN 
	IsFaulted := (State = eCapInsertStaState.eUnknown);
ELSE 
	IsFaulted := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="Ready" Id="{936f23dc-3d4c-43b4-bbe0-637012b2c79f}">
      <Declaration><![CDATA[PROPERTY PUBLIC Ready : BOOL]]></Declaration>
      <Get Name="Get" Id="{ac2098eb-1e18-4427-88b6-95219f60e00d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF (LotsData.Lot.CapInsertEnabled) THEN
 Ready := (State = eCapInsertStaState.eWaitForVehicleTrigger);
ELSE
	Ready := TRUE;
 //Ready := (State = eCapInsertStaState.eDisabledReady);	//we removed the physical cap station on 10/17 
END_IF]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="ResetState" Id="{396c4cb9-5b33-468d-8ff2-2d435bdd913b}">
      <Declaration><![CDATA[METHOD PUBLIC ResetState : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[	State := eCapInsertStaState.eUnknown;
	NextState := eCapInsertStaState.eUnknown;]]></ST>
      </Implementation>
    </Method>
    <Property Name="Trigger" Id="{889ef549-96af-46e4-8dd7-5261bc0f4a20}">
      <Declaration><![CDATA[PROPERTY PUBLIC Trigger : BOOL]]></Declaration>
      <Set Name="Set" Id="{e2d85bc5-da04-4f2d-a15e-9446fed1a848}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[xTrigger := Trigger;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="UpdatePartData" Id="{e2dcb88b-320d-47fa-bc2b-5d07e66fcb82}">
      <Declaration><![CDATA[METHOD PUBLIC UpdatePartData : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[PartsData.Status[VUT].OverallStatus := ePartStatus.eCapInserted;
PartsData.Status[VUT].CapPass := TRUE;
PartsData.Status[VUT].CapInsertTime := SYSTEMTIME_TO_STRING(Logging.fbCurrTime.systemTime);]]></ST>
      </Implementation>
    </Method>
    <Property Name="VehicleUnderTest" Id="{f9107988-9378-427e-b057-300727cd452b}">
      <Declaration><![CDATA[PROPERTY PUBLIC VehicleUnderTest : BYTE]]></Declaration>
      <Get Name="Get" Id="{fbb5e15b-fea8-42f5-b34e-edf334c9b495}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[VehicleUnderTest := VUT;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{9b218616-d2c7-4f0f-9484-280dc8861b58}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[VUT := VehicleUnderTest;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <LineIds Name="CapInsertStation_Old">
      <LineId Id="1581" Count="0" />
      <LineId Id="1577" Count="2" />
      <LineId Id="1582" Count="0" />
      <LineId Id="1580" Count="0" />
      <LineId Id="1584" Count="0" />
      <LineId Id="1587" Count="0" />
      <LineId Id="1585" Count="0" />
      <LineId Id="1588" Count="0" />
      <LineId Id="1586" Count="0" />
      <LineId Id="1576" Count="0" />
      <LineId Id="891" Count="1" />
      <LineId Id="1668" Count="0" />
      <LineId Id="893" Count="11" />
      <LineId Id="1427" Count="1" />
      <LineId Id="907" Count="4" />
      <LineId Id="1648" Count="0" />
      <LineId Id="1647" Count="0" />
      <LineId Id="1650" Count="0" />
      <LineId Id="912" Count="18" />
      <LineId Id="1398" Count="0" />
      <LineId Id="931" Count="2" />
      <LineId Id="935" Count="5" />
      <LineId Id="1669" Count="0" />
      <LineId Id="941" Count="10" />
      <LineId Id="1405" Count="1" />
      <LineId Id="1368" Count="0" />
      <LineId Id="953" Count="0" />
      <LineId Id="1524" Count="0" />
      <LineId Id="1526" Count="0" />
      <LineId Id="1525" Count="0" />
      <LineId Id="1356" Count="0" />
      <LineId Id="960" Count="3" />
      <LineId Id="1597" Count="0" />
      <LineId Id="1599" Count="0" />
      <LineId Id="1598" Count="0" />
      <LineId Id="964" Count="6" />
      <LineId Id="1670" Count="0" />
      <LineId Id="971" Count="1" />
      <LineId Id="1589" Count="1" />
      <LineId Id="1593" Count="3" />
      <LineId Id="1600" Count="2" />
      <LineId Id="1671" Count="0" />
      <LineId Id="1591" Count="0" />
      <LineId Id="1490" Count="1" />
      <LineId Id="1488" Count="0" />
      <LineId Id="1492" Count="11" />
      <LineId Id="1529" Count="0" />
      <LineId Id="1505" Count="0" />
      <LineId Id="1528" Count="0" />
      <LineId Id="1527" Count="0" />
      <LineId Id="1506" Count="0" />
      <LineId Id="1531" Count="0" />
      <LineId Id="1534" Count="0" />
      <LineId Id="1532" Count="0" />
      <LineId Id="1536" Count="0" />
      <LineId Id="1539" Count="1" />
      <LineId Id="1553" Count="1" />
      <LineId Id="1673" Count="0" />
      <LineId Id="1533" Count="0" />
      <LineId Id="1507" Count="0" />
      <LineId Id="1541" Count="2" />
      <LineId Id="1546" Count="0" />
      <LineId Id="1549" Count="3" />
      <LineId Id="1674" Count="0" />
      <LineId Id="1544" Count="0" />
      <LineId Id="1508" Count="0" />
      <LineId Id="1489" Count="0" />
      <LineId Id="973" Count="11" />
      <LineId Id="1407" Count="0" />
      <LineId Id="985" Count="0" />
      <LineId Id="987" Count="6" />
      <LineId Id="1556" Count="0" />
      <LineId Id="1555" Count="0" />
      <LineId Id="994" Count="8" />
      <LineId Id="1672" Count="0" />
      <LineId Id="1003" Count="16" />
      <LineId Id="1675" Count="1" />
      <LineId Id="1020" Count="4" />
      <LineId Id="1558" Count="0" />
      <LineId Id="1557" Count="0" />
      <LineId Id="1025" Count="9" />
      <LineId Id="1677" Count="1" />
      <LineId Id="1035" Count="5" />
      <LineId Id="1399" Count="0" />
      <LineId Id="1041" Count="22" />
      <LineId Id="1426" Count="0" />
      <LineId Id="1064" Count="8" />
      <LineId Id="1396" Count="0" />
      <LineId Id="1073" Count="5" />
      <LineId Id="1332" Count="0" />
      <LineId Id="1079" Count="0" />
      <LineId Id="1334" Count="0" />
      <LineId Id="1342" Count="0" />
      <LineId Id="1425" Count="0" />
      <LineId Id="1330" Count="0" />
      <LineId Id="1333" Count="0" />
      <LineId Id="1336" Count="0" />
      <LineId Id="1679" Count="1" />
      <LineId Id="1331" Count="0" />
      <LineId Id="1082" Count="1" />
      <LineId Id="1338" Count="0" />
      <LineId Id="1341" Count="0" />
      <LineId Id="1343" Count="2" />
      <LineId Id="1354" Count="1" />
      <LineId Id="1348" Count="0" />
      <LineId Id="1351" Count="0" />
      <LineId Id="1353" Count="0" />
      <LineId Id="1397" Count="0" />
      <LineId Id="1400" Count="0" />
      <LineId Id="1352" Count="0" />
      <LineId Id="1347" Count="0" />
      <LineId Id="1340" Count="0" />
      <LineId Id="1339" Count="0" />
      <LineId Id="1084" Count="49" />
      <LineId Id="1681" Count="0" />
      <LineId Id="1134" Count="15" />
      <LineId Id="1683" Count="1" />
      <LineId Id="1150" Count="8" />
      <LineId Id="1394" Count="0" />
      <LineId Id="1447" Count="0" />
      <LineId Id="1159" Count="7" />
      <LineId Id="1685" Count="0" />
      <LineId Id="1167" Count="19" />
      <LineId Id="1686" Count="1" />
      <LineId Id="1187" Count="33" />
      <LineId Id="1695" Count="0" />
      <LineId Id="1697" Count="0" />
      <LineId Id="1699" Count="0" />
      <LineId Id="1696" Count="0" />
      <LineId Id="1694" Count="0" />
      <LineId Id="1221" Count="15" />
      <LineId Id="1395" Count="0" />
      <LineId Id="1237" Count="15" />
      <LineId Id="1688" Count="1" />
      <LineId Id="1253" Count="29" />
      <LineId Id="1690" Count="1" />
      <LineId Id="1283" Count="23" />
      <LineId Id="1692" Count="1" />
      <LineId Id="1307" Count="6" />
      <LineId Id="1624" Count="0" />
      <LineId Id="1623" Count="0" />
      <LineId Id="1315" Count="0" />
      <LineId Id="1625" Count="0" />
      <LineId Id="1627" Count="0" />
      <LineId Id="1626" Count="0" />
      <LineId Id="1317" Count="0" />
      <LineId Id="1622" Count="0" />
      <LineId Id="1621" Count="0" />
      <LineId Id="1628" Count="1" />
      <LineId Id="1700" Count="0" />
      <LineId Id="1620" Count="0" />
      <LineId Id="1318" Count="11" />
      <LineId Id="1429" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="CapInsertStation_Old.AssignStationStatusForHMI">
      <LineId Id="10" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="11" Count="1" />
      <LineId Id="74" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="87" Count="1" />
      <LineId Id="13" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="CapInsertStation_Old.ClearVehicleTrigger">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="CapInsertStation_Old.IsFaulted">
      <LineId Id="9" Count="1" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="CapInsertStation_Old.Ready.Get">
      <LineId Id="3" Count="4" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="CapInsertStation_Old.ResetState">
      <LineId Id="6" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="CapInsertStation_Old.Trigger.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="CapInsertStation_Old.UpdatePartData">
      <LineId Id="9" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="CapInsertStation_Old.VehicleUnderTest.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="CapInsertStation_Old.VehicleUnderTest.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>